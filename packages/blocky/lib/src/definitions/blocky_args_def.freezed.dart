// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'blocky_args_def.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$BlockyArgsDef {
  bool Function(Map<String, dynamic>)? get onCondition =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String text, ConditionCheck? onCondition)
        dummyText,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputStr,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputNum,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputBool,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputVar,
    required TResult Function(
            String name,
            String key,
            Map<String, String> enumeration,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputEnum,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String text, ConditionCheck? onCondition)? dummyText,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputStr,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputNum,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputBool,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputVar,
    TResult? Function(
            String name,
            String key,
            Map<String, String> enumeration,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)?
        inputEnum,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String text, ConditionCheck? onCondition)? dummyText,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputStr,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputNum,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputBool,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputVar,
    TResult Function(
            String name,
            String key,
            Map<String, String> enumeration,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)?
        inputEnum,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlockyArgsDefDummyText value) dummyText,
    required TResult Function(BlockyArgsDefInputStr value) inputStr,
    required TResult Function(BlockyArgsDefInputNum value) inputNum,
    required TResult Function(BlockyArgsDefInputBool value) inputBool,
    required TResult Function(BlockyArgsDefInputVar value) inputVar,
    required TResult Function(BlockyArgsDefInputEnum value) inputEnum,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlockyArgsDefDummyText value)? dummyText,
    TResult? Function(BlockyArgsDefInputStr value)? inputStr,
    TResult? Function(BlockyArgsDefInputNum value)? inputNum,
    TResult? Function(BlockyArgsDefInputBool value)? inputBool,
    TResult? Function(BlockyArgsDefInputVar value)? inputVar,
    TResult? Function(BlockyArgsDefInputEnum value)? inputEnum,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlockyArgsDefDummyText value)? dummyText,
    TResult Function(BlockyArgsDefInputStr value)? inputStr,
    TResult Function(BlockyArgsDefInputNum value)? inputNum,
    TResult Function(BlockyArgsDefInputBool value)? inputBool,
    TResult Function(BlockyArgsDefInputVar value)? inputVar,
    TResult Function(BlockyArgsDefInputEnum value)? inputEnum,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BlockyArgsDefCopyWith<BlockyArgsDef> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BlockyArgsDefCopyWith<$Res> {
  factory $BlockyArgsDefCopyWith(
          BlockyArgsDef value, $Res Function(BlockyArgsDef) then) =
      _$BlockyArgsDefCopyWithImpl<$Res, BlockyArgsDef>;
  @useResult
  $Res call({bool Function(Map<String, dynamic>)? onCondition});
}

/// @nodoc
class _$BlockyArgsDefCopyWithImpl<$Res, $Val extends BlockyArgsDef>
    implements $BlockyArgsDefCopyWith<$Res> {
  _$BlockyArgsDefCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? onCondition = freezed,
  }) {
    return _then(_value.copyWith(
      onCondition: freezed == onCondition
          ? _value.onCondition
          : onCondition // ignore: cast_nullable_to_non_nullable
              as bool Function(Map<String, dynamic>)?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BlockyArgsDefDummyTextImplCopyWith<$Res>
    implements $BlockyArgsDefCopyWith<$Res> {
  factory _$$BlockyArgsDefDummyTextImplCopyWith(
          _$BlockyArgsDefDummyTextImpl value,
          $Res Function(_$BlockyArgsDefDummyTextImpl) then) =
      __$$BlockyArgsDefDummyTextImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String text, ConditionCheck? onCondition});
}

/// @nodoc
class __$$BlockyArgsDefDummyTextImplCopyWithImpl<$Res>
    extends _$BlockyArgsDefCopyWithImpl<$Res, _$BlockyArgsDefDummyTextImpl>
    implements _$$BlockyArgsDefDummyTextImplCopyWith<$Res> {
  __$$BlockyArgsDefDummyTextImplCopyWithImpl(
      _$BlockyArgsDefDummyTextImpl _value,
      $Res Function(_$BlockyArgsDefDummyTextImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? text = null,
    Object? onCondition = freezed,
  }) {
    return _then(_$BlockyArgsDefDummyTextImpl(
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
      onCondition: freezed == onCondition
          ? _value.onCondition
          : onCondition // ignore: cast_nullable_to_non_nullable
              as ConditionCheck?,
    ));
  }
}

/// @nodoc

class _$BlockyArgsDefDummyTextImpl
    with DiagnosticableTreeMixin
    implements BlockyArgsDefDummyText {
  const _$BlockyArgsDefDummyTextImpl({required this.text, this.onCondition});

  @override
  final String text;
  @override
  final ConditionCheck? onCondition;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BlockyArgsDef.dummyText(text: $text, onCondition: $onCondition)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'BlockyArgsDef.dummyText'))
      ..add(DiagnosticsProperty('text', text))
      ..add(DiagnosticsProperty('onCondition', onCondition));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlockyArgsDefDummyTextImpl &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.onCondition, onCondition) ||
                other.onCondition == onCondition));
  }

  @override
  int get hashCode => Object.hash(runtimeType, text, onCondition);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BlockyArgsDefDummyTextImplCopyWith<_$BlockyArgsDefDummyTextImpl>
      get copyWith => __$$BlockyArgsDefDummyTextImplCopyWithImpl<
          _$BlockyArgsDefDummyTextImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String text, ConditionCheck? onCondition)
        dummyText,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputStr,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputNum,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputBool,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputVar,
    required TResult Function(
            String name,
            String key,
            Map<String, String> enumeration,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputEnum,
  }) {
    return dummyText(text, onCondition);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String text, ConditionCheck? onCondition)? dummyText,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputStr,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputNum,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputBool,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputVar,
    TResult? Function(
            String name,
            String key,
            Map<String, String> enumeration,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)?
        inputEnum,
  }) {
    return dummyText?.call(text, onCondition);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String text, ConditionCheck? onCondition)? dummyText,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputStr,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputNum,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputBool,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputVar,
    TResult Function(
            String name,
            String key,
            Map<String, String> enumeration,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)?
        inputEnum,
    required TResult orElse(),
  }) {
    if (dummyText != null) {
      return dummyText(text, onCondition);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlockyArgsDefDummyText value) dummyText,
    required TResult Function(BlockyArgsDefInputStr value) inputStr,
    required TResult Function(BlockyArgsDefInputNum value) inputNum,
    required TResult Function(BlockyArgsDefInputBool value) inputBool,
    required TResult Function(BlockyArgsDefInputVar value) inputVar,
    required TResult Function(BlockyArgsDefInputEnum value) inputEnum,
  }) {
    return dummyText(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlockyArgsDefDummyText value)? dummyText,
    TResult? Function(BlockyArgsDefInputStr value)? inputStr,
    TResult? Function(BlockyArgsDefInputNum value)? inputNum,
    TResult? Function(BlockyArgsDefInputBool value)? inputBool,
    TResult? Function(BlockyArgsDefInputVar value)? inputVar,
    TResult? Function(BlockyArgsDefInputEnum value)? inputEnum,
  }) {
    return dummyText?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlockyArgsDefDummyText value)? dummyText,
    TResult Function(BlockyArgsDefInputStr value)? inputStr,
    TResult Function(BlockyArgsDefInputNum value)? inputNum,
    TResult Function(BlockyArgsDefInputBool value)? inputBool,
    TResult Function(BlockyArgsDefInputVar value)? inputVar,
    TResult Function(BlockyArgsDefInputEnum value)? inputEnum,
    required TResult orElse(),
  }) {
    if (dummyText != null) {
      return dummyText(this);
    }
    return orElse();
  }
}

abstract class BlockyArgsDefDummyText implements BlockyArgsDef {
  const factory BlockyArgsDefDummyText(
      {required final String text,
      final ConditionCheck? onCondition}) = _$BlockyArgsDefDummyTextImpl;

  String get text;
  @override
  ConditionCheck? get onCondition;
  @override
  @JsonKey(ignore: true)
  _$$BlockyArgsDefDummyTextImplCopyWith<_$BlockyArgsDefDummyTextImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BlockyArgsDefInputStrImplCopyWith<$Res>
    implements $BlockyArgsDefCopyWith<$Res> {
  factory _$$BlockyArgsDefInputStrImplCopyWith(
          _$BlockyArgsDefInputStrImpl value,
          $Res Function(_$BlockyArgsDefInputStrImpl) then) =
      __$$BlockyArgsDefInputStrImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String name,
      String key,
      BlockyLiteralType checkType,
      bool nilable,
      ConditionCheck? onCondition});
}

/// @nodoc
class __$$BlockyArgsDefInputStrImplCopyWithImpl<$Res>
    extends _$BlockyArgsDefCopyWithImpl<$Res, _$BlockyArgsDefInputStrImpl>
    implements _$$BlockyArgsDefInputStrImplCopyWith<$Res> {
  __$$BlockyArgsDefInputStrImplCopyWithImpl(_$BlockyArgsDefInputStrImpl _value,
      $Res Function(_$BlockyArgsDefInputStrImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? key = null,
    Object? checkType = null,
    Object? nilable = null,
    Object? onCondition = freezed,
  }) {
    return _then(_$BlockyArgsDefInputStrImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      key: null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
      checkType: null == checkType
          ? _value.checkType
          : checkType // ignore: cast_nullable_to_non_nullable
              as BlockyLiteralType,
      nilable: null == nilable
          ? _value.nilable
          : nilable // ignore: cast_nullable_to_non_nullable
              as bool,
      onCondition: freezed == onCondition
          ? _value.onCondition
          : onCondition // ignore: cast_nullable_to_non_nullable
              as ConditionCheck?,
    ));
  }
}

/// @nodoc

class _$BlockyArgsDefInputStrImpl
    with DiagnosticableTreeMixin
    implements BlockyArgsDefInputStr {
  const _$BlockyArgsDefInputStrImpl(
      {required this.name,
      required this.key,
      this.checkType = BlockyLiteralType.str,
      this.nilable = false,
      this.onCondition});

  @override
  final String name;
  @override
  final String key;
  @override
  @JsonKey()
  final BlockyLiteralType checkType;
  @override
  @JsonKey()
  final bool nilable;
  @override
  final ConditionCheck? onCondition;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BlockyArgsDef.inputStr(name: $name, key: $key, checkType: $checkType, nilable: $nilable, onCondition: $onCondition)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'BlockyArgsDef.inputStr'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('key', key))
      ..add(DiagnosticsProperty('checkType', checkType))
      ..add(DiagnosticsProperty('nilable', nilable))
      ..add(DiagnosticsProperty('onCondition', onCondition));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlockyArgsDefInputStrImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.checkType, checkType) ||
                other.checkType == checkType) &&
            (identical(other.nilable, nilable) || other.nilable == nilable) &&
            (identical(other.onCondition, onCondition) ||
                other.onCondition == onCondition));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, name, key, checkType, nilable, onCondition);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BlockyArgsDefInputStrImplCopyWith<_$BlockyArgsDefInputStrImpl>
      get copyWith => __$$BlockyArgsDefInputStrImplCopyWithImpl<
          _$BlockyArgsDefInputStrImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String text, ConditionCheck? onCondition)
        dummyText,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputStr,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputNum,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputBool,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputVar,
    required TResult Function(
            String name,
            String key,
            Map<String, String> enumeration,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputEnum,
  }) {
    return inputStr(name, key, checkType, nilable, onCondition);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String text, ConditionCheck? onCondition)? dummyText,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputStr,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputNum,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputBool,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputVar,
    TResult? Function(
            String name,
            String key,
            Map<String, String> enumeration,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)?
        inputEnum,
  }) {
    return inputStr?.call(name, key, checkType, nilable, onCondition);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String text, ConditionCheck? onCondition)? dummyText,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputStr,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputNum,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputBool,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputVar,
    TResult Function(
            String name,
            String key,
            Map<String, String> enumeration,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)?
        inputEnum,
    required TResult orElse(),
  }) {
    if (inputStr != null) {
      return inputStr(name, key, checkType, nilable, onCondition);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlockyArgsDefDummyText value) dummyText,
    required TResult Function(BlockyArgsDefInputStr value) inputStr,
    required TResult Function(BlockyArgsDefInputNum value) inputNum,
    required TResult Function(BlockyArgsDefInputBool value) inputBool,
    required TResult Function(BlockyArgsDefInputVar value) inputVar,
    required TResult Function(BlockyArgsDefInputEnum value) inputEnum,
  }) {
    return inputStr(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlockyArgsDefDummyText value)? dummyText,
    TResult? Function(BlockyArgsDefInputStr value)? inputStr,
    TResult? Function(BlockyArgsDefInputNum value)? inputNum,
    TResult? Function(BlockyArgsDefInputBool value)? inputBool,
    TResult? Function(BlockyArgsDefInputVar value)? inputVar,
    TResult? Function(BlockyArgsDefInputEnum value)? inputEnum,
  }) {
    return inputStr?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlockyArgsDefDummyText value)? dummyText,
    TResult Function(BlockyArgsDefInputStr value)? inputStr,
    TResult Function(BlockyArgsDefInputNum value)? inputNum,
    TResult Function(BlockyArgsDefInputBool value)? inputBool,
    TResult Function(BlockyArgsDefInputVar value)? inputVar,
    TResult Function(BlockyArgsDefInputEnum value)? inputEnum,
    required TResult orElse(),
  }) {
    if (inputStr != null) {
      return inputStr(this);
    }
    return orElse();
  }
}

abstract class BlockyArgsDefInputStr implements BlockyArgsDef {
  const factory BlockyArgsDefInputStr(
      {required final String name,
      required final String key,
      final BlockyLiteralType checkType,
      final bool nilable,
      final ConditionCheck? onCondition}) = _$BlockyArgsDefInputStrImpl;

  String get name;
  String get key;
  BlockyLiteralType get checkType;
  bool get nilable;
  @override
  ConditionCheck? get onCondition;
  @override
  @JsonKey(ignore: true)
  _$$BlockyArgsDefInputStrImplCopyWith<_$BlockyArgsDefInputStrImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BlockyArgsDefInputNumImplCopyWith<$Res>
    implements $BlockyArgsDefCopyWith<$Res> {
  factory _$$BlockyArgsDefInputNumImplCopyWith(
          _$BlockyArgsDefInputNumImpl value,
          $Res Function(_$BlockyArgsDefInputNumImpl) then) =
      __$$BlockyArgsDefInputNumImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String name,
      String key,
      BlockyLiteralType checkType,
      bool nilable,
      ConditionCheck? onCondition});
}

/// @nodoc
class __$$BlockyArgsDefInputNumImplCopyWithImpl<$Res>
    extends _$BlockyArgsDefCopyWithImpl<$Res, _$BlockyArgsDefInputNumImpl>
    implements _$$BlockyArgsDefInputNumImplCopyWith<$Res> {
  __$$BlockyArgsDefInputNumImplCopyWithImpl(_$BlockyArgsDefInputNumImpl _value,
      $Res Function(_$BlockyArgsDefInputNumImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? key = null,
    Object? checkType = null,
    Object? nilable = null,
    Object? onCondition = freezed,
  }) {
    return _then(_$BlockyArgsDefInputNumImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      key: null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
      checkType: null == checkType
          ? _value.checkType
          : checkType // ignore: cast_nullable_to_non_nullable
              as BlockyLiteralType,
      nilable: null == nilable
          ? _value.nilable
          : nilable // ignore: cast_nullable_to_non_nullable
              as bool,
      onCondition: freezed == onCondition
          ? _value.onCondition
          : onCondition // ignore: cast_nullable_to_non_nullable
              as ConditionCheck?,
    ));
  }
}

/// @nodoc

class _$BlockyArgsDefInputNumImpl
    with DiagnosticableTreeMixin
    implements BlockyArgsDefInputNum {
  const _$BlockyArgsDefInputNumImpl(
      {required this.name,
      required this.key,
      this.checkType = BlockyLiteralType.num,
      this.nilable = false,
      this.onCondition});

  @override
  final String name;
  @override
  final String key;
  @override
  @JsonKey()
  final BlockyLiteralType checkType;
  @override
  @JsonKey()
  final bool nilable;
  @override
  final ConditionCheck? onCondition;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BlockyArgsDef.inputNum(name: $name, key: $key, checkType: $checkType, nilable: $nilable, onCondition: $onCondition)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'BlockyArgsDef.inputNum'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('key', key))
      ..add(DiagnosticsProperty('checkType', checkType))
      ..add(DiagnosticsProperty('nilable', nilable))
      ..add(DiagnosticsProperty('onCondition', onCondition));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlockyArgsDefInputNumImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.checkType, checkType) ||
                other.checkType == checkType) &&
            (identical(other.nilable, nilable) || other.nilable == nilable) &&
            (identical(other.onCondition, onCondition) ||
                other.onCondition == onCondition));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, name, key, checkType, nilable, onCondition);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BlockyArgsDefInputNumImplCopyWith<_$BlockyArgsDefInputNumImpl>
      get copyWith => __$$BlockyArgsDefInputNumImplCopyWithImpl<
          _$BlockyArgsDefInputNumImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String text, ConditionCheck? onCondition)
        dummyText,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputStr,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputNum,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputBool,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputVar,
    required TResult Function(
            String name,
            String key,
            Map<String, String> enumeration,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputEnum,
  }) {
    return inputNum(name, key, checkType, nilable, onCondition);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String text, ConditionCheck? onCondition)? dummyText,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputStr,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputNum,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputBool,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputVar,
    TResult? Function(
            String name,
            String key,
            Map<String, String> enumeration,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)?
        inputEnum,
  }) {
    return inputNum?.call(name, key, checkType, nilable, onCondition);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String text, ConditionCheck? onCondition)? dummyText,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputStr,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputNum,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputBool,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputVar,
    TResult Function(
            String name,
            String key,
            Map<String, String> enumeration,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)?
        inputEnum,
    required TResult orElse(),
  }) {
    if (inputNum != null) {
      return inputNum(name, key, checkType, nilable, onCondition);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlockyArgsDefDummyText value) dummyText,
    required TResult Function(BlockyArgsDefInputStr value) inputStr,
    required TResult Function(BlockyArgsDefInputNum value) inputNum,
    required TResult Function(BlockyArgsDefInputBool value) inputBool,
    required TResult Function(BlockyArgsDefInputVar value) inputVar,
    required TResult Function(BlockyArgsDefInputEnum value) inputEnum,
  }) {
    return inputNum(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlockyArgsDefDummyText value)? dummyText,
    TResult? Function(BlockyArgsDefInputStr value)? inputStr,
    TResult? Function(BlockyArgsDefInputNum value)? inputNum,
    TResult? Function(BlockyArgsDefInputBool value)? inputBool,
    TResult? Function(BlockyArgsDefInputVar value)? inputVar,
    TResult? Function(BlockyArgsDefInputEnum value)? inputEnum,
  }) {
    return inputNum?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlockyArgsDefDummyText value)? dummyText,
    TResult Function(BlockyArgsDefInputStr value)? inputStr,
    TResult Function(BlockyArgsDefInputNum value)? inputNum,
    TResult Function(BlockyArgsDefInputBool value)? inputBool,
    TResult Function(BlockyArgsDefInputVar value)? inputVar,
    TResult Function(BlockyArgsDefInputEnum value)? inputEnum,
    required TResult orElse(),
  }) {
    if (inputNum != null) {
      return inputNum(this);
    }
    return orElse();
  }
}

abstract class BlockyArgsDefInputNum implements BlockyArgsDef {
  const factory BlockyArgsDefInputNum(
      {required final String name,
      required final String key,
      final BlockyLiteralType checkType,
      final bool nilable,
      final ConditionCheck? onCondition}) = _$BlockyArgsDefInputNumImpl;

  String get name;
  String get key;
  BlockyLiteralType get checkType;
  bool get nilable;
  @override
  ConditionCheck? get onCondition;
  @override
  @JsonKey(ignore: true)
  _$$BlockyArgsDefInputNumImplCopyWith<_$BlockyArgsDefInputNumImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BlockyArgsDefInputBoolImplCopyWith<$Res>
    implements $BlockyArgsDefCopyWith<$Res> {
  factory _$$BlockyArgsDefInputBoolImplCopyWith(
          _$BlockyArgsDefInputBoolImpl value,
          $Res Function(_$BlockyArgsDefInputBoolImpl) then) =
      __$$BlockyArgsDefInputBoolImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String name,
      String key,
      BlockyLiteralType checkType,
      bool nilable,
      ConditionCheck? onCondition});
}

/// @nodoc
class __$$BlockyArgsDefInputBoolImplCopyWithImpl<$Res>
    extends _$BlockyArgsDefCopyWithImpl<$Res, _$BlockyArgsDefInputBoolImpl>
    implements _$$BlockyArgsDefInputBoolImplCopyWith<$Res> {
  __$$BlockyArgsDefInputBoolImplCopyWithImpl(
      _$BlockyArgsDefInputBoolImpl _value,
      $Res Function(_$BlockyArgsDefInputBoolImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? key = null,
    Object? checkType = null,
    Object? nilable = null,
    Object? onCondition = freezed,
  }) {
    return _then(_$BlockyArgsDefInputBoolImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      key: null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
      checkType: null == checkType
          ? _value.checkType
          : checkType // ignore: cast_nullable_to_non_nullable
              as BlockyLiteralType,
      nilable: null == nilable
          ? _value.nilable
          : nilable // ignore: cast_nullable_to_non_nullable
              as bool,
      onCondition: freezed == onCondition
          ? _value.onCondition
          : onCondition // ignore: cast_nullable_to_non_nullable
              as ConditionCheck?,
    ));
  }
}

/// @nodoc

class _$BlockyArgsDefInputBoolImpl
    with DiagnosticableTreeMixin
    implements BlockyArgsDefInputBool {
  const _$BlockyArgsDefInputBoolImpl(
      {required this.name,
      required this.key,
      this.checkType = BlockyLiteralType.bool,
      this.nilable = false,
      this.onCondition});

  @override
  final String name;
  @override
  final String key;
  @override
  @JsonKey()
  final BlockyLiteralType checkType;
  @override
  @JsonKey()
  final bool nilable;
  @override
  final ConditionCheck? onCondition;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BlockyArgsDef.inputBool(name: $name, key: $key, checkType: $checkType, nilable: $nilable, onCondition: $onCondition)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'BlockyArgsDef.inputBool'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('key', key))
      ..add(DiagnosticsProperty('checkType', checkType))
      ..add(DiagnosticsProperty('nilable', nilable))
      ..add(DiagnosticsProperty('onCondition', onCondition));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlockyArgsDefInputBoolImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.checkType, checkType) ||
                other.checkType == checkType) &&
            (identical(other.nilable, nilable) || other.nilable == nilable) &&
            (identical(other.onCondition, onCondition) ||
                other.onCondition == onCondition));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, name, key, checkType, nilable, onCondition);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BlockyArgsDefInputBoolImplCopyWith<_$BlockyArgsDefInputBoolImpl>
      get copyWith => __$$BlockyArgsDefInputBoolImplCopyWithImpl<
          _$BlockyArgsDefInputBoolImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String text, ConditionCheck? onCondition)
        dummyText,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputStr,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputNum,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputBool,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputVar,
    required TResult Function(
            String name,
            String key,
            Map<String, String> enumeration,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputEnum,
  }) {
    return inputBool(name, key, checkType, nilable, onCondition);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String text, ConditionCheck? onCondition)? dummyText,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputStr,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputNum,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputBool,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputVar,
    TResult? Function(
            String name,
            String key,
            Map<String, String> enumeration,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)?
        inputEnum,
  }) {
    return inputBool?.call(name, key, checkType, nilable, onCondition);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String text, ConditionCheck? onCondition)? dummyText,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputStr,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputNum,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputBool,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputVar,
    TResult Function(
            String name,
            String key,
            Map<String, String> enumeration,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)?
        inputEnum,
    required TResult orElse(),
  }) {
    if (inputBool != null) {
      return inputBool(name, key, checkType, nilable, onCondition);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlockyArgsDefDummyText value) dummyText,
    required TResult Function(BlockyArgsDefInputStr value) inputStr,
    required TResult Function(BlockyArgsDefInputNum value) inputNum,
    required TResult Function(BlockyArgsDefInputBool value) inputBool,
    required TResult Function(BlockyArgsDefInputVar value) inputVar,
    required TResult Function(BlockyArgsDefInputEnum value) inputEnum,
  }) {
    return inputBool(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlockyArgsDefDummyText value)? dummyText,
    TResult? Function(BlockyArgsDefInputStr value)? inputStr,
    TResult? Function(BlockyArgsDefInputNum value)? inputNum,
    TResult? Function(BlockyArgsDefInputBool value)? inputBool,
    TResult? Function(BlockyArgsDefInputVar value)? inputVar,
    TResult? Function(BlockyArgsDefInputEnum value)? inputEnum,
  }) {
    return inputBool?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlockyArgsDefDummyText value)? dummyText,
    TResult Function(BlockyArgsDefInputStr value)? inputStr,
    TResult Function(BlockyArgsDefInputNum value)? inputNum,
    TResult Function(BlockyArgsDefInputBool value)? inputBool,
    TResult Function(BlockyArgsDefInputVar value)? inputVar,
    TResult Function(BlockyArgsDefInputEnum value)? inputEnum,
    required TResult orElse(),
  }) {
    if (inputBool != null) {
      return inputBool(this);
    }
    return orElse();
  }
}

abstract class BlockyArgsDefInputBool implements BlockyArgsDef {
  const factory BlockyArgsDefInputBool(
      {required final String name,
      required final String key,
      final BlockyLiteralType checkType,
      final bool nilable,
      final ConditionCheck? onCondition}) = _$BlockyArgsDefInputBoolImpl;

  String get name;
  String get key;
  BlockyLiteralType get checkType;
  bool get nilable;
  @override
  ConditionCheck? get onCondition;
  @override
  @JsonKey(ignore: true)
  _$$BlockyArgsDefInputBoolImplCopyWith<_$BlockyArgsDefInputBoolImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BlockyArgsDefInputVarImplCopyWith<$Res>
    implements $BlockyArgsDefCopyWith<$Res> {
  factory _$$BlockyArgsDefInputVarImplCopyWith(
          _$BlockyArgsDefInputVarImpl value,
          $Res Function(_$BlockyArgsDefInputVarImpl) then) =
      __$$BlockyArgsDefInputVarImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String name,
      String key,
      BlockyLiteralType checkType,
      bool nilable,
      ConditionCheck? onCondition});
}

/// @nodoc
class __$$BlockyArgsDefInputVarImplCopyWithImpl<$Res>
    extends _$BlockyArgsDefCopyWithImpl<$Res, _$BlockyArgsDefInputVarImpl>
    implements _$$BlockyArgsDefInputVarImplCopyWith<$Res> {
  __$$BlockyArgsDefInputVarImplCopyWithImpl(_$BlockyArgsDefInputVarImpl _value,
      $Res Function(_$BlockyArgsDefInputVarImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? key = null,
    Object? checkType = null,
    Object? nilable = null,
    Object? onCondition = freezed,
  }) {
    return _then(_$BlockyArgsDefInputVarImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      key: null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
      checkType: null == checkType
          ? _value.checkType
          : checkType // ignore: cast_nullable_to_non_nullable
              as BlockyLiteralType,
      nilable: null == nilable
          ? _value.nilable
          : nilable // ignore: cast_nullable_to_non_nullable
              as bool,
      onCondition: freezed == onCondition
          ? _value.onCondition
          : onCondition // ignore: cast_nullable_to_non_nullable
              as ConditionCheck?,
    ));
  }
}

/// @nodoc

class _$BlockyArgsDefInputVarImpl
    with DiagnosticableTreeMixin
    implements BlockyArgsDefInputVar {
  const _$BlockyArgsDefInputVarImpl(
      {required this.name,
      required this.key,
      this.checkType = BlockyLiteralType.str,
      this.nilable = false,
      this.onCondition});

  @override
  final String name;
  @override
  final String key;
  @override
  @JsonKey()
  final BlockyLiteralType checkType;
  @override
  @JsonKey()
  final bool nilable;
  @override
  final ConditionCheck? onCondition;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BlockyArgsDef.inputVar(name: $name, key: $key, checkType: $checkType, nilable: $nilable, onCondition: $onCondition)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'BlockyArgsDef.inputVar'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('key', key))
      ..add(DiagnosticsProperty('checkType', checkType))
      ..add(DiagnosticsProperty('nilable', nilable))
      ..add(DiagnosticsProperty('onCondition', onCondition));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlockyArgsDefInputVarImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.checkType, checkType) ||
                other.checkType == checkType) &&
            (identical(other.nilable, nilable) || other.nilable == nilable) &&
            (identical(other.onCondition, onCondition) ||
                other.onCondition == onCondition));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, name, key, checkType, nilable, onCondition);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BlockyArgsDefInputVarImplCopyWith<_$BlockyArgsDefInputVarImpl>
      get copyWith => __$$BlockyArgsDefInputVarImplCopyWithImpl<
          _$BlockyArgsDefInputVarImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String text, ConditionCheck? onCondition)
        dummyText,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputStr,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputNum,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputBool,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputVar,
    required TResult Function(
            String name,
            String key,
            Map<String, String> enumeration,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputEnum,
  }) {
    return inputVar(name, key, checkType, nilable, onCondition);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String text, ConditionCheck? onCondition)? dummyText,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputStr,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputNum,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputBool,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputVar,
    TResult? Function(
            String name,
            String key,
            Map<String, String> enumeration,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)?
        inputEnum,
  }) {
    return inputVar?.call(name, key, checkType, nilable, onCondition);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String text, ConditionCheck? onCondition)? dummyText,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputStr,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputNum,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputBool,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputVar,
    TResult Function(
            String name,
            String key,
            Map<String, String> enumeration,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)?
        inputEnum,
    required TResult orElse(),
  }) {
    if (inputVar != null) {
      return inputVar(name, key, checkType, nilable, onCondition);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlockyArgsDefDummyText value) dummyText,
    required TResult Function(BlockyArgsDefInputStr value) inputStr,
    required TResult Function(BlockyArgsDefInputNum value) inputNum,
    required TResult Function(BlockyArgsDefInputBool value) inputBool,
    required TResult Function(BlockyArgsDefInputVar value) inputVar,
    required TResult Function(BlockyArgsDefInputEnum value) inputEnum,
  }) {
    return inputVar(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlockyArgsDefDummyText value)? dummyText,
    TResult? Function(BlockyArgsDefInputStr value)? inputStr,
    TResult? Function(BlockyArgsDefInputNum value)? inputNum,
    TResult? Function(BlockyArgsDefInputBool value)? inputBool,
    TResult? Function(BlockyArgsDefInputVar value)? inputVar,
    TResult? Function(BlockyArgsDefInputEnum value)? inputEnum,
  }) {
    return inputVar?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlockyArgsDefDummyText value)? dummyText,
    TResult Function(BlockyArgsDefInputStr value)? inputStr,
    TResult Function(BlockyArgsDefInputNum value)? inputNum,
    TResult Function(BlockyArgsDefInputBool value)? inputBool,
    TResult Function(BlockyArgsDefInputVar value)? inputVar,
    TResult Function(BlockyArgsDefInputEnum value)? inputEnum,
    required TResult orElse(),
  }) {
    if (inputVar != null) {
      return inputVar(this);
    }
    return orElse();
  }
}

abstract class BlockyArgsDefInputVar implements BlockyArgsDef {
  const factory BlockyArgsDefInputVar(
      {required final String name,
      required final String key,
      final BlockyLiteralType checkType,
      final bool nilable,
      final ConditionCheck? onCondition}) = _$BlockyArgsDefInputVarImpl;

  String get name;
  String get key;
  BlockyLiteralType get checkType;
  bool get nilable;
  @override
  ConditionCheck? get onCondition;
  @override
  @JsonKey(ignore: true)
  _$$BlockyArgsDefInputVarImplCopyWith<_$BlockyArgsDefInputVarImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BlockyArgsDefInputEnumImplCopyWith<$Res>
    implements $BlockyArgsDefCopyWith<$Res> {
  factory _$$BlockyArgsDefInputEnumImplCopyWith(
          _$BlockyArgsDefInputEnumImpl value,
          $Res Function(_$BlockyArgsDefInputEnumImpl) then) =
      __$$BlockyArgsDefInputEnumImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String name,
      String key,
      Map<String, String> enumeration,
      BlockyLiteralType checkType,
      bool nilable,
      ConditionCheck? onCondition});
}

/// @nodoc
class __$$BlockyArgsDefInputEnumImplCopyWithImpl<$Res>
    extends _$BlockyArgsDefCopyWithImpl<$Res, _$BlockyArgsDefInputEnumImpl>
    implements _$$BlockyArgsDefInputEnumImplCopyWith<$Res> {
  __$$BlockyArgsDefInputEnumImplCopyWithImpl(
      _$BlockyArgsDefInputEnumImpl _value,
      $Res Function(_$BlockyArgsDefInputEnumImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? key = null,
    Object? enumeration = null,
    Object? checkType = null,
    Object? nilable = null,
    Object? onCondition = freezed,
  }) {
    return _then(_$BlockyArgsDefInputEnumImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      key: null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
      enumeration: null == enumeration
          ? _value._enumeration
          : enumeration // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
      checkType: null == checkType
          ? _value.checkType
          : checkType // ignore: cast_nullable_to_non_nullable
              as BlockyLiteralType,
      nilable: null == nilable
          ? _value.nilable
          : nilable // ignore: cast_nullable_to_non_nullable
              as bool,
      onCondition: freezed == onCondition
          ? _value.onCondition
          : onCondition // ignore: cast_nullable_to_non_nullable
              as ConditionCheck?,
    ));
  }
}

/// @nodoc

class _$BlockyArgsDefInputEnumImpl
    with DiagnosticableTreeMixin
    implements BlockyArgsDefInputEnum {
  const _$BlockyArgsDefInputEnumImpl(
      {required this.name,
      required this.key,
      required final Map<String, String> enumeration,
      this.checkType = BlockyLiteralType.str,
      this.nilable = false,
      this.onCondition})
      : _enumeration = enumeration;

  @override
  final String name;
  @override
  final String key;
  final Map<String, String> _enumeration;
  @override
  Map<String, String> get enumeration {
    if (_enumeration is EqualUnmodifiableMapView) return _enumeration;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_enumeration);
  }

  @override
  @JsonKey()
  final BlockyLiteralType checkType;
  @override
  @JsonKey()
  final bool nilable;
  @override
  final ConditionCheck? onCondition;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BlockyArgsDef.inputEnum(name: $name, key: $key, enumeration: $enumeration, checkType: $checkType, nilable: $nilable, onCondition: $onCondition)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'BlockyArgsDef.inputEnum'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('key', key))
      ..add(DiagnosticsProperty('enumeration', enumeration))
      ..add(DiagnosticsProperty('checkType', checkType))
      ..add(DiagnosticsProperty('nilable', nilable))
      ..add(DiagnosticsProperty('onCondition', onCondition));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlockyArgsDefInputEnumImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.key, key) || other.key == key) &&
            const DeepCollectionEquality()
                .equals(other._enumeration, _enumeration) &&
            (identical(other.checkType, checkType) ||
                other.checkType == checkType) &&
            (identical(other.nilable, nilable) || other.nilable == nilable) &&
            (identical(other.onCondition, onCondition) ||
                other.onCondition == onCondition));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      name,
      key,
      const DeepCollectionEquality().hash(_enumeration),
      checkType,
      nilable,
      onCondition);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BlockyArgsDefInputEnumImplCopyWith<_$BlockyArgsDefInputEnumImpl>
      get copyWith => __$$BlockyArgsDefInputEnumImplCopyWithImpl<
          _$BlockyArgsDefInputEnumImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String text, ConditionCheck? onCondition)
        dummyText,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputStr,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputNum,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputBool,
    required TResult Function(
            String name,
            String key,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputVar,
    required TResult Function(
            String name,
            String key,
            Map<String, String> enumeration,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)
        inputEnum,
  }) {
    return inputEnum(name, key, enumeration, checkType, nilable, onCondition);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String text, ConditionCheck? onCondition)? dummyText,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputStr,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputNum,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputBool,
    TResult? Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputVar,
    TResult? Function(
            String name,
            String key,
            Map<String, String> enumeration,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)?
        inputEnum,
  }) {
    return inputEnum?.call(
        name, key, enumeration, checkType, nilable, onCondition);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String text, ConditionCheck? onCondition)? dummyText,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputStr,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputNum,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputBool,
    TResult Function(String name, String key, BlockyLiteralType checkType,
            bool nilable, ConditionCheck? onCondition)?
        inputVar,
    TResult Function(
            String name,
            String key,
            Map<String, String> enumeration,
            BlockyLiteralType checkType,
            bool nilable,
            ConditionCheck? onCondition)?
        inputEnum,
    required TResult orElse(),
  }) {
    if (inputEnum != null) {
      return inputEnum(name, key, enumeration, checkType, nilable, onCondition);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlockyArgsDefDummyText value) dummyText,
    required TResult Function(BlockyArgsDefInputStr value) inputStr,
    required TResult Function(BlockyArgsDefInputNum value) inputNum,
    required TResult Function(BlockyArgsDefInputBool value) inputBool,
    required TResult Function(BlockyArgsDefInputVar value) inputVar,
    required TResult Function(BlockyArgsDefInputEnum value) inputEnum,
  }) {
    return inputEnum(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlockyArgsDefDummyText value)? dummyText,
    TResult? Function(BlockyArgsDefInputStr value)? inputStr,
    TResult? Function(BlockyArgsDefInputNum value)? inputNum,
    TResult? Function(BlockyArgsDefInputBool value)? inputBool,
    TResult? Function(BlockyArgsDefInputVar value)? inputVar,
    TResult? Function(BlockyArgsDefInputEnum value)? inputEnum,
  }) {
    return inputEnum?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlockyArgsDefDummyText value)? dummyText,
    TResult Function(BlockyArgsDefInputStr value)? inputStr,
    TResult Function(BlockyArgsDefInputNum value)? inputNum,
    TResult Function(BlockyArgsDefInputBool value)? inputBool,
    TResult Function(BlockyArgsDefInputVar value)? inputVar,
    TResult Function(BlockyArgsDefInputEnum value)? inputEnum,
    required TResult orElse(),
  }) {
    if (inputEnum != null) {
      return inputEnum(this);
    }
    return orElse();
  }
}

abstract class BlockyArgsDefInputEnum implements BlockyArgsDef {
  const factory BlockyArgsDefInputEnum(
      {required final String name,
      required final String key,
      required final Map<String, String> enumeration,
      final BlockyLiteralType checkType,
      final bool nilable,
      final ConditionCheck? onCondition}) = _$BlockyArgsDefInputEnumImpl;

  String get name;
  String get key;
  Map<String, String> get enumeration;
  BlockyLiteralType get checkType;
  bool get nilable;
  @override
  ConditionCheck? get onCondition;
  @override
  @JsonKey(ignore: true)
  _$$BlockyArgsDefInputEnumImplCopyWith<_$BlockyArgsDefInputEnumImpl>
      get copyWith => throw _privateConstructorUsedError;
}
